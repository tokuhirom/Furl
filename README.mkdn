# NAME

Furl - Lightning-fast URL fetcher

# SYNOPSIS

    use Furl;

    my $furl = Furl->new(
        agent   => 'MyGreatUA/2.0',
        timeout => 10,
    );

    my ($code, $msg, $headers, $body) = $furl->request(
        method => 'GET',
        host   => 'example.com',
        port   => 80,
        path   => '/'
    );
    # or
    my ($code, $msg, $headers, $body) = $furl->get('http://example.com/');
    my ($code, $msg, $headers, $body) = $furl->post(
        'http://example.com/', # URL
        [...],                 # headers
        [ foo => 'bar' ],      # form data (HashRef/FileHandle are also okay)
    );

    # Accept-Encoding is supported but optional
    $furl = Furl->new(
        headers => [ 'Accept-Encoding' => 'gzip' ],
    );
    my $body = $furl->get('http://example.com/some/compressed');

# DESCRIPTION

Furl is yet another HTTP client library. LWP is the de facto standard HTTP
client for Perl5, but it is too slow for some critical jobs, and too complex
for weekend hacking. Furl resolves these issues. Enjoy it!

This library is an __alpha__ software. Any API may change without notice.

# INTERFACE

## Class Methods

### C<< Furl->new(%args | \%args) :Furl >>

Creates and returns a new Furl client with _%args_. Dies on errors.

_%args_ might be:

- agent :Str = "Furl/$VERSION"

- timeout :Int = 10

- max_redirects :Int = 7

- proxy :Str

- headers :ArrayRef

## Instance Methods

### C<< $furl->request(%args) :($code, $msg, \@headers, $body) >>

Sends an HTTP request to a specified URL and returns a status code,
status message, response headers, response body respectively.

_%args_ might be:

- scheme :Str = "http"

- host :Str

- port :Int = 80

- path_query :Str = "/"

- url :Str

You can use `url` instead of `scheme`, `host`, `port` and `path_query`.

- headers :ArrayRef

- content : Str | ArrayRef[Str] | HashRef[Str] | FileHandle

You must encode all the queries or this method will die, saying
`Wide character in ...`.

### C<< $furl->get($url :Str, $headers :ArrayRef[Str] ) :List >>

This is an easy-to-use alias to `request()`.

### C<< $furl->head($url :Str, $headers :ArrayRef[Str] ) :List >>

This is an easy-to-use alias to `request()`.

### C<< $furl->post($url :Str, $headers :ArrayRef[Str], $content :Any) :List >>

This is an easy-to-use alias to `request()`.

### C<< $furl->put($url :Str, $headers :ArrayRef[Str], $content :Any) :List >>

This is an easy-to-use alias to `request()`.

### C<< $furl->delete($url :Str, $headers :ArrayRef[Str] ) :List >>

This is an easy-to-use alias to `request()`.

### C<< $furl->request_with_http_request($req :HTTP::Request) :List >>

This is an easy-to-use alias to `request()`.

### C<< $furl->env_proxy() >>

Loads proxy settings from `$ENV{HTTP_PROXY}`.

## Utilitis

### C<< Furl::Util::header_get(\@headers, $name :Str) :Maybe[Str] >>

This is equivalent to `Plack::Util::header_get()`.

# INTEGRATE WITH HTTP::Response

Some useful libraries require HTTP::Response instances for their arguments.
You can easily create its instance from the result of `request()` and other HTTP request methods.

    my $res = HTTP::Response->new($furl->get($url));

# PROJECT POLICY

- Why IO::Socket::SSL?

Net::SSL is not well documented.

- Why is env_proxy optional?

Environment variables are highly dependent on each users' environment,
and we think it may confuse users when something doesn't go right.

- What operating systems are supported?

Linux 2.6 or higher, OSX Tiger or higher, Windows XP or higher.

And we can support other operating systems if you send a patch.

- Why doesn't Furl support chunked upload?

There are reasons why chunked POST/PUTs should not be used in general.

First, you cannot send chunked requests unless the peer server at the other end of the established TCP connection is known to be a HTTP/1.1 server.

Second, HTTP/1.1 servers disconnect their persistent connection quite quickly (compared to the time they wait for the first request), so it is not a good idea to post non-idempotent requests (e.g. POST, PUT, etc.) as a succeeding request over persistent connections.

These facts together makes using chunked requests virtually impossible (unless you _know_ that the server supports HTTP/1.1), and this is why we decided that supporting the feature is NOT of high priority.

# FAQ

- How do you build the response content as it arrives?

You can use [IO::Callback](http://search.cpan.org/perldoc?IO::Callback) for this purpose.

    my $fh = IO::Callback->new(
        '<',
        sub {
            my $x = shift @data;
            $x ? "-$x" : undef;
        }
    );
    my ( $code, $msg, $headers, $content ) =
      $furl->put( "http://127.0.0.1:$port/", [ 'Content-Length' => $len ], $fh,
      );

- How do you use cookie_jar?

Furl does not directly support the cookie_jar option available in LWP. You can use [HTTP::Cookies](http://search.cpan.org/perldoc?HTTP::Cookies), [HTTP::Request](http://search.cpan.org/perldoc?HTTP::Request), [HTTP::Response](http://search.cpan.org/perldoc?HTTP::Response) like following.

    my $f = Furl->new();
    my $cookies = HTTP::Cookies->new();
    my $req = HTTP::Request->new(...);
    $cookies->add_cookie_header($req);
    my $res = HTTP::Response->new($f->request_with_http_request($req));
    $cookies->extract_cookies($res);
    # and use $res.

- How do you use gzip/deflate compressed communication?

Add an __Accept-Encoding__ header to your request. Furl inflates response bodies transparently according to the __Content-Encoding__ response header.


# DEVELOPMENT

To setup your environment:

    $ git clone http://github.com/tokuhirom/p5-Furl.git
    $ cd p5-Furl

To get pico http parser:

    $ git submodule init
    $ git submodule update

    $ perl Makefile.PL
    $ make 
    $ sudo make install

# TODO

Before First Release

    - Docs, docs, docs!

After First Release

    - AnyEvent::Furl?
    - change the parser_http_response args. and backport to HTTP::Response::Parser.
        my($headers, $retcode, ...) = parse_http_response($buf, $last_len, @specific_headers)
    - use HTTP::Response::Parser
    - PP version(by HTTP::Respones::Parser)
    - multipart/form-data support
    - ipv6 support

# OPTIONAL FEATURES

## Internationalized Domain Name (IDN)

This feature requires Net::IDN::Encode.

## SSL

This feature requires IO::Socket::SSL.

## Content-Encoding (deflate, gzip)

This feature requires Compress::Raw::Zlib.

# AUTHOR

Tokuhiro Matsuno <tokuhirom AAJKLFJEF GMAIL COM>

gfx

# THANKS TO

Kazuho Oku

mala

mattn

# SEE ALSO

[LWP](http://search.cpan.org/perldoc?LWP)

HTTP specs:
<http://www.w3.org/Protocols/HTTP/1.0/spec.html>
<http://www.w3.org/Protocols/HTTP/1.1/spec.html>

# LICENSE

Copyright (C) Tokuhiro Matsuno

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
